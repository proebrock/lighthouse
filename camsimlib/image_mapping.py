""" Module for mapping of image points to image indices

Image points as generated by ProjectiveGeometry and its subclasses
provide "image points" (x,y) with x in [0..width) and y in [0..height)
with chip size of (width, height).

Image indices (row, col) on the other hand for an image of shape
(rows, cols) are different. For integer indices, row is in [0..rows-1] and
col in [0..cols-1]. For float indices with subpixel accuracy,
row is in [-0.5..rows-0.5) and col is in [-0.5..cols-0.5).
"""

import numpy as np



def image_points_to_indices(points):
    """ Convert image points to image indices
    :param points: Image points (x, y) in shape (n, 2)
    :return: Image indices (row, col) in shape (n, 2)
    """
    assert points.ndim == 2
    assert points.shape[1] == 2
    indices = np.zeros((points.shape[0], 2))
    indices[:, 0] = points[:, 1] - 0.5
    indices[:, 1] = points[:, 0] - 0.5
    return indices



def image_indices_to_points(indices):
    """ Convert image indices to image points
    :param indices: Image indices (row, col) in shape (n, 2)
    :return: Image points (x, y) in shape (n, 2)
    """
    assert indices.ndim == 2
    assert indices.shape[1] == 2
    points = np.zeros((indices.shape[0], 2))
    points[:, 0] = indices[:, 1] + 0.5
    points[:, 1] = indices[:, 0] + 0.5
    return points



def image_points_on_chip_mask(points, chip_size):
    """ Check if image points are on chip
    For 3D points P projected by the projective geometry, it is not
    guaranteed the projected points p are on the chip. A point outside
    the field of view e.g. does not end up on the chip after projection.
    This method provides a mask of all points that are actually on the chip.
    Method can deal with NaN points (which are not on the chip).
    :param points: Image points (x, y) in shape (n, 2)
    :return: Mask in shape (n, )
    """
    assert points.ndim == 2
    assert points.shape[1] == 2
    assert len(chip_size) == 2
    return np.logical_and.reduce((
        points[:, 0] >= 0,
        points[:, 0] < chip_size[0],
        points[:, 1] >= 0,
        points[:, 1] < chip_size[1],
        ))



def image_indices_on_chip_mask(indices, chip_size):
    """ Check if image indices are on chip
    For 3D points P projected by the projective geometry, it is not
    guaranteed the projected points p are on the chip. A point outside
    the field of view e.g. does not end up on the chip after projection.
    This method provides a mask of all indices that are actually on the chip.
    Method can deal with NaN points (which are not on the chip).
    :param indices: Image indices (row, col) in shape (n, 2)
    :return: Mask in shape (n, )
    """
    assert indices.ndim == 2
    assert indices.shape[1] == 2
    assert len(chip_size) == 2
    return np.logical_and.reduce((
        indices[:, 0] >= -0.5,
        indices[:, 0] < (chip_size[1] - 0.5),
        indices[:, 1] >= -0.5,
        indices[:, 1] < (chip_size[0] - 0.5),
        ))



def image_sample_points_coarse(image, points):
    """ Sample image points from an image
    Image points are converted to indices and those are
    rounded and converted to integers for sampling from the image;
    this is simple and fast, but we loose sub-pixel accuracy.
    :param image: Input image, can be RGB image or float image
    :param points: Image points (x, y) in shape (n, 2)
    :return: Samples of image of shape (n, 3) for RGB or (n, ) for float images
    """
    assert image.ndim in [2, 3]
    assert points.ndim == 2
    assert points.shape[1] == 2
    indices = image_points_to_indices(points)
    chip_size = (image.shape[1], image.shape[0])
    on_chip_mask = image_indices_on_chip_mask(indices, chip_size)
    indices = indices[on_chip_mask, :]
    indices = np.round(indices).astype(int)
    samples = image[indices[:, 0], indices[:, 1], ...]
    return samples, on_chip_mask
